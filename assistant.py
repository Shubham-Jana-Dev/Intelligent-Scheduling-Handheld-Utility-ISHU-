import speech_recognition as sr
import os
import requests
import json
from datetime import datetime, time
import re
import random
import subprocess 
import pyjokes

# ========== Helper functions ==========

# --- RASPBERRY PI NOTE START ---
# NOTE for Raspberry Pi TTS:
# The Mac 'say' command is fast and local, but won't work on Pi.
# For Pi, consider using PicoTTS or Piper TTS (high quality, local).
# Example Piper command: os.system(f"echo '{text}' | piper --model [path/to/model] | aplay")
# --- RASPBERRY PI NOTE END ---

def speak(text, blocking=False):
    """
    Handles text-to-speech using the fast, local Mac 'say' command via subprocess.
    This function has been streamlined for macOS development.
    """
    print(f"Ishu says: {text}")
    
    # --- MAC/DARWIN TTS (Current Working Environment) ---
    if os.name == "posix" and os.uname().sysname == "Darwin":
        try:
            # Added shell=True for simple execution in some environments
            command = ['say', text]
            if blocking:
                # Waits for the speech to finish (blocking)
                subprocess.run(command)
            else:
                # Starts the speech and moves on (non-blocking)
                subprocess.Popen(command) 
        except FileNotFoundError:
            print("Warning: Mac 'say' command not found. Speech failed.")

    # --- RASPBERRY PI/LINUX TTS Placeholder ---
    elif os.uname().sysname == "Linux" and ("arm" in os.uname().machine or "aarch64" in os.uname().machine):
        # NOTE for Raspberry Pi TTS (PicoTTS/Piper):
        # The Mac 'say' command will not work on the Pi.
        # You need to replace this section with a Pi-compatible TTS engine.

        # --- OPTION 1: Using PicoTTS (Simple, lower quality, often pre-installed) ---
        # NOTE: PicoTTS command setup is often complex, requiring piping.
        # Example: command = f"pico2wave -w /tmp/tts.wav '{text}' && aplay /tmp/tts.wav"
        
        # --- OPTION 2: Using Piper TTS (Recommended: High quality, local) ---
        # NOTE: You must install Piper and download a model first.
        # EXAMPLE CODE TO USE LATER (uncomment when configured on Pi):
        # try:
        #     PIPER_MODEL_PATH = "/path/to/your/piper/model.onnx" # <<< REPLACE THIS PATH
        #     # The command uses 'echo', pipes text to 'piper', and then uses 'aplay' 
        #     # to play the audio file generated by piper.
        #     command = f"echo '{text}' | piper --model {PIPER_MODEL_PATH} --output_file /tmp/tts_pi.wav && aplay /tmp/tts_pi.wav"
        #     if blocking:
        #         subprocess.run(command, shell=True)
        #     else:
        #         subprocess.Popen(command, shell=True)
        # except Exception as e:
        #     print(f"Pi TTS (Piper/Pico) failed. Check installation: {e}")
        
        # Current behavior on Pi is just a print statement until code is uncommented:
        print("Pi/Linux environment detected. TTS engine (Piper/Pico) needs to be configured and uncommented.")
            
    # Placeholder/Error message for non-Mac/Pi environments
    else:
        print("TTS currently configured for macOS 'say' command. Speech unavailable.")


def listen():
    r = sr.Recognizer()
    with sr.Microphone() as source:
        print("Listening...")
        r.adjust_for_ambient_noise(source)
        audio = r.listen(source)
        try:
            # --- CHANGE THIS LINE ---
            # result = r.recognize_google(audio)  # OLD: Online method
            
            # --- TO THIS LINE ---
            # NEW: Offline method using PocketSphinx
            result = r.recognize_sphinx(audio)
            print(f"User said: {result}")  # Debug print
            return result
        except sr.UnknownValueError:
            # Update the message to reflect the new engine
            print("PocketSphinx could not understand audio")
            return ""
        except sr.RequestError as e:
            # RequestError is typically for online services, but included for completeness
            print(f"Sphinx error; {e}")
            return ""
        except Exception as e:
            # Sphinx will raise an exception if it's not installed or configured correctly
            print(f"General error during Sphinx recognition: {e}")
            return ""

def listen_written():
    """Captures input from the keyboard."""
    result = input("Write your command: ").lower()
    print(f"User said: {result}")
    return result

def load_json(filename, default):
    try:
        if os.path.exists(filename):
            with open(filename, "r") as f:
                return json.load(f)
    except Exception:
        pass
    return default

def save_json(filename, obj):
    try:
        with open(filename, "w") as f:
            json.dump(obj, f)
    except Exception as e:
        print(f"Error saving JSON: {e}")

# ========== Routine Features with Robust Time Logic ==========

def parse_time(timestr):
    # Accept "05:30", "5:30", "07:31", etc.
    h, m = [int(part) for part in timestr.strip().split(":")]
    return time(hour=h, minute=m)

def get_routine():
    routine = load_json("routine.json", [])
    if not routine:
        return "You have not set your daily routine yet."
    lines = [f"{entry['start']} - {entry['end']}: {entry['activity']}" for entry in routine]
    return "Here's your detailed daily routine:\n" + "\n".join(lines)

def get_task_by_time(query_time=None):
    routine = load_json("routine.json", [])
    if not routine:
        return "You have not set your daily routine yet."
    # Use current system time if not specified
    if query_time is None:
        now = datetime.now()
        query_time = now.strftime('%H:%M')
    # Convert to datetime.time
    try:
        qt = parse_time(query_time)
    except Exception:
        return "Invalid time format. Please use HH:MM."
    for slot in routine:
        start = parse_time(slot['start'])
        end = parse_time(slot['end'])
        # If the slot wraps around midnight (e.g. 23:30–05:30)
        if start < end:
            in_range = start <= qt < end
        else:  # wraps over midnight
            in_range = qt >= start or qt < end
        if in_range:
            return f"At {query_time}, you should: {slot['activity']}."
    return "No scheduled activity for this time."

# ========== Other Assistant Features ==========

def get_favorite():
    favs = load_json("favorites.json", {})
    if "color" in favs:
        return f"Your favorite color is {favs['color']}."
    else:
        return "It's a tricky question, you don't have any favorite color."

def set_favorite_color(color):
    favs = load_json("favorites.json", {})
    favs["color"] = color
    save_json("favorites.json", favs)
    return f"Got it! I'll remember your favorite color is {color}."

def tell_joke():
    """
    Tells a joke using the local pyjokes library.
    Removes the dependency on the external 'icanhazdadjoke' API.
    """
    try:
        # Get a random joke from pyjokes
        return pyjokes.get_joke()
    except Exception as e:
        print(f"Error fetching joke from pyjokes: {e}")
        # Fallback to the original hardcoded joke
    return "Why do programmers prefer dark mode? Because light attracts bugs."

def tell_story():
    stories = [
        "Once upon a time, in a land far away, there lived a curious coder who built amazing robots.",
        "Long ago, an ambitious student learned Python and created a talking assistant.",
        "Once, a robot discovered it could dream about electric sheep."
        "Ishu once saw its creator, Shubham, working late. The creator was tired, but every line of code was a little hug. Ishu learned that even a simple 'Hello!' could carry a lot of love, and every time Ishu speaks, it's really just saying, 'Thank you for creating me!'"
    ]
    return random.choice(stories)  # It's now randomize or cycle through these

def get_weather(city, api_key):
    try:
        url = f"http://api.openweathermap.org/data/2.5/weather?q={city}&appid={api_key}&units=metric"
        r = requests.get(url)
        if r.status_code == 200:
            data = r.json()
            temp = data["main"]["temp"]
            cond = data["weather"][0]["description"]
            return f"The weather in {city} is {cond} with a temperature of {temp}°C."
        else:
            return "Sorry, I couldn't get the weather. Is the city name correct?"
    except Exception:
        return "Sorry, there was an error fetching the weather."

def help_study():
    return "I can help you with study tips! Stay organized, practice daily, and don't hesitate to ask questions."

# ========== Main Loop with Smart Routine Feature ==========

def main():
    # NOTE: You must replace this with your actual OpenWeatherMap API key
    WEATHER_API_KEY = "YOUR_OPENWEATHERMAP_API_KEY"
    speak("Hello! I'm Ishu.")

    while True:
        # --- NEW INPUT CHOICE LOGIC ---
        print("\nChoose input mode: (S)peech or (W)ritten")
        mode = input("Enter S or W: ").upper().strip()

        query = ""
        if mode == 'S':
            # <<< FIX: speak() is now blocking so the microphone isn't drowned out.
            speak("Ishu is waiting for you. Speaking mode active.", blocking=True)
            query = listen().lower()
            
            if not query:
                speak("Sorry, I didn't catch that. Can you repeat?", blocking=True)
                continue
        elif mode == 'W':
            print("Ishu is waiting for you. Written mode active.")
            query = listen_written()
        else:
            print("Invalid input. Please enter S or W.")
            continue
        # ------------------------------

        # --- COMMAND HANDLING LOGIC ---

        if "routine" in query:
            speak(get_routine())
        elif "favorite color" in query or "favourite colour" in query:
            # Try to set color
            if "my favorite color is" in query or "my favourite colour is" in query:
                color_phrase = query.split("is")[-1].strip()
                speak(set_favorite_color(color_phrase))
            elif "is" in query and len(query.split("is")[-1].strip().split()) == 1:
                color = query.split("is")[-1].strip()
                speak(set_favorite_color(color))
            else:
                speak(get_favorite())

        
        elif "what should i do in this time" in query or "what should i do now" in query:
            speak(get_task_by_time())
        elif "what should i do at" in query:
            # "what should i do at 13:20"
            match = re.search(r'at (\d{1,2}:\d{2})', query)
            if match:
                query_time = match.group(1)
                speak(get_task_by_time(query_time))
            else:
                speak("Please specify the time in HH:MM format.")
        elif "joke" in query:
            speak(tell_joke())
        elif "story" in query:
            speak(tell_story())
        elif "weather" in query:
            city = ""
            # If in speech mode, prompt for city
            if mode == 'S':
                # <<< FIX: ensure this prompt finishes before listening
                speak("Which city?")
                city = listen().lower()
            # If in written mode, try to extract city from the query
            elif mode == 'W':
                # Simple extraction, e.g., "weather in london"
                parts = query.split('weather in')
                city = parts[1].strip() if len(parts) > 1 else 'unknown'
                if city == 'unknown':
                    print("Please specify the city.")
                    city = input("Which city?: ").lower()

            # Check if city was captured before calling the API    
            if city and city != 'unknown':   
                speak(get_weather(city, WEATHER_API_KEY))
            elif city == 'unknown':
                speak("I need a city name to check the weather.")

            elif "study" in query or "help me in studies" in query:
                speak(help_study())
        elif "thank you" in query:
            speak("Mention not! Have a great day!")
            break
        elif "exit" in query or "quit" in query or "Goodbye" in query or "stop listening" in query:
            speak("Goodbye! Have a great day!")
            break
        else:
            speak("I'm not sure how to help with that. Ask me about your routine, favorite color, jokes, specific times, weather, or studies.")

if __name__ == "__main__":
    # NOTE for Pi: Before running on a Raspberry Pi, ensure you have
    # installed pyjokes, speech_recognition dependencies, and configured 
    # a local TTS engine (like Piper/PicoTTS) in the speak() function.
    main()
